var bad_format_doc = {
  "_id": "25250e2ead108a8f60213f2404007c91",
  "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
  "doctype": "bim",
  "description": "",
  "fieldsets": [{
    "id": "b9ad37ea17a58d9be32160f393770e5d",
    "multiple": false,
    "collapse": false,
    "name": "hip",
    "label": "Hip",
    "order": 50,
    "fields": [{
      "id": "25250e2ead108a8f60213f24040007e4",
      "name": "caltest",
      "label": "CalTest",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "25250e2ead108a8f60213f2404005d38",
      "regex": "",
      "order": 50,
      "subcategory": "date",
      "value": "23-1990-08"
    },
    {
      "id": "25250e2ead108a8f60213f240400248f",
      "name": "ff",
      "label": "FF",
      "head": false,
      "reversal": false,
      "required": false,
      "min": 0,
      "max": 10,
      "instance": "25250e2ead108a8f60213f2404006a4d",
      "regex": "",
      "order": 50,
      "subcategory": "integer",
      "value": ""
    },
    {
      "id": "b9ad37ea17a58d9be32160f393771cdd",
      "name": "yer",
      "label": "Yer",
      "head": true,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "25250e2ead108a8f60213f240400717c",
      "regex": "",
      "order": 50,
      "subcategory": "boolean",
      "value": false
    }]
  }],
  "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
  "created_by_": "admin"
};
var early_doc = {
  "_id": "25250e2ead108a8f60213f2404007c91",
  "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
  "doctype": "bim",
  "description": "",
  "fieldsets": [{
    "id": "b9ad37ea17a58d9be32160f393770e5d",
    "multiple": false,
    "collapse": false,
    "name": "hip",
    "label": "Hip",
    "order": 50,
    "fields": [{
      "id": "25250e2ead108a8f60213f24040007e4",
      "name": "caltest",
      "label": "CalTest",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "1990-09-23",
      "max": "",
      "instance": "25250e2ead108a8f60213f2404005d38",
      "regex": "",
      "order": 50,
      "subcategory": "date",
      "value": "1990-08-23"
    },
    {
      "id": "25250e2ead108a8f60213f240400248f",
      "name": "ff",
      "label": "FF",
      "head": false,
      "reversal": false,
      "required": false,
      "min": 0,
      "max": 10,
      "instance": "25250e2ead108a8f60213f2404006a4d",
      "regex": "",
      "order": 50,
      "subcategory": "integer",
      "value": ""
    },
    {
      "id": "b9ad37ea17a58d9be32160f393771cdd",
      "name": "yer",
      "label": "Yer",
      "head": true,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "25250e2ead108a8f60213f240400717c",
      "regex": "",
      "order": 50,
      "subcategory": "boolean",
      "value": false
    }]
  }],
  "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
  "created_by_": "admin"
};
var high_integer = {
  "doctype": "bim",
  "description": "",
  "fieldsets": [{
    "id": "b9ad37ea17a58d9be32160f393770e5d",
    "multiple": false,
    "collapse": false,
    "name": "hip",
    "label": "Hip",
    "order": 50,
    "fields": [{
      "id": "25250e2ead108a8f60213f24040007e4",
      "name": "caltest",
      "label": "CalTest",
      "head": true,
      "reversal": false,
      "required": false,
      "min": "2001-09-27",
      "max": "2010-08-15",
      "instance": "4d915decf693d51ab06a2f10920ca8d2",
      "regex": "",
      "order": 50,
      "subcategory": "date",
      "value": "2009-09-20"
    },
    {
      "id": "25250e2ead108a8f60213f240400248f",
      "name": "ff",
      "label": "FF",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "",
      "max": 0,
      "instance": "4d915decf693d51ab06a2f10920cb7ee",
      "regex": "",
      "order": 50,
      "subcategory": "integer",
      "value": 6
    },
    {
      "id": "b9ad37ea17a58d9be32160f393771cdd",
      "name": "yer",
      "label": "Yer",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "4d915decf693d51ab06a2f10920cc144",
      "regex": "",
      "order": 50,
      "subcategory": "boolean",
      "value": true
    }]
  }]
};
var late_doc = {
  "_id": "25250e2ead108a8f60213f2404007c91",
  "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
  "doctype": "bim",
  "description": "",
  "fieldsets": [{
    "id": "b9ad37ea17a58d9be32160f393770e5d",
    "multiple": false,
    "collapse": false,
    "name": "hip",
    "label": "Hip",
    "order": 50,
    "fields": [{
      "id": "25250e2ead108a8f60213f24040007e4",
      "name": "caltest",
      "label": "CalTest",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "1990-07-23",
      "instance": "25250e2ead108a8f60213f2404005d38",
      "regex": "",
      "order": 50,
      "subcategory": "date",
      "value": "1990-08-23"
    },
    {
      "id": "25250e2ead108a8f60213f240400248f",
      "name": "ff",
      "label": "FF",
      "head": false,
      "reversal": false,
      "required": false,
      "min": 0,
      "max": 10,
      "instance": "25250e2ead108a8f60213f2404006a4d",
      "regex": "",
      "order": 50,
      "subcategory": "integer",
      "value": ""
    },
    {
      "id": "b9ad37ea17a58d9be32160f393771cdd",
      "name": "yer",
      "label": "Yer",
      "head": true,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "25250e2ead108a8f60213f240400717c",
      "regex": "",
      "order": 50,
      "subcategory": "boolean",
      "value": false
    }]
  }],
  "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
  "created_by_": "admin"
};
var lower_integer = {
  "doctype": "bim",
  "description": "",
  "fieldsets": [{
    "id": "b9ad37ea17a58d9be32160f393770e5d",
    "multiple": false,
    "collapse": false,
    "name": "hip",
    "label": "Hip",
    "order": 50,
    "fields": [{
      "id": "25250e2ead108a8f60213f24040007e4",
      "name": "caltest",
      "label": "CalTest",
      "head": true,
      "reversal": false,
      "required": false,
      "min": "2001-09-27",
      "max": "2010-08-15",
      "instance": "4d915decf693d51ab06a2f10920ca8d2",
      "regex": "",
      "order": 50,
      "subcategory": "date",
      "value": "2009-09-20"
    },
    {
      "id": "25250e2ead108a8f60213f240400248f",
      "name": "ff",
      "label": "FF",
      "head": false,
      "reversal": false,
      "required": false,
      "min": 0,
      "max": "",
      "instance": "4d915decf693d51ab06a2f10920cb7ee",
      "regex": "",
      "order": 50,
      "subcategory": "integer",
      "value": -6
    },
    {
      "id": "b9ad37ea17a58d9be32160f393771cdd",
      "name": "yer",
      "label": "Yer",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "4d915decf693d51ab06a2f10920cc144",
      "regex": "",
      "order": 50,
      "subcategory": "boolean",
      "value": true
    }]
  }]
};
var simple_doc = {
  "_id": "25250e2ead108a8f60213f2404007c91",
  "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
  "doctype": "bim",
  "description": "",
  "fieldsets": [{
    "id": "b9ad37ea17a58d9be32160f393770e5d",
    "multiple": false,
    "collapse": false,
    "name": "hip",
    "label": "Hip",
    "order": 50,
    "fields": [{
      "id": "25250e2ead108a8f60213f24040007e4",
      "name": "caltest",
      "label": "CalTest",
      "head": false,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "25250e2ead108a8f60213f2404005d38",
      "regex": "",
      "order": 50,
      "subcategory": "date",
      "value": "1990-08-23"
    },
    {
      "id": "25250e2ead108a8f60213f240400248f",
      "name": "ff",
      "label": "FF",
      "head": false,
      "reversal": false,
      "required": false,
      "min": 0,
      "max": 10,
      "instance": "25250e2ead108a8f60213f2404006a4d",
      "regex": "",
      "order": 50,
      "subcategory": "integer",
      "value": ""
    },
    {
      "id": "b9ad37ea17a58d9be32160f393771cdd",
      "name": "yer",
      "label": "Yer",
      "head": true,
      "reversal": false,
      "required": false,
      "min": "",
      "max": "",
      "instance": "25250e2ead108a8f60213f240400717c",
      "regex": "",
      "order": 50,
      "subcategory": "boolean",
      "value": false
    }]
  }],
  "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
  "created_by_": "admin"
};
var future_doc = function (theDate) {
  return {
    "_id": "25250e2ead108a8f60213f2404007c91",
    "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
    "doctype": "bim",
    "description": "",
    "fieldsets": [{
      "id": "b9ad37ea17a58d9be32160f393770e5d",
      "multiple": false,
      "collapse": false,
      "name": "hip",
      "label": "Hip",
      "order": 50,
      "fields": [{
        "id": "25250e2ead108a8f60213f24040007e4",
        "name": "caltest",
        "label": "CalTest",
        "head": false,
        "reversal": false,
        "required": false,
        "min": "",
        "max": "today",
        "instance": "25250e2ead108a8f60213f2404005d38",
        "regex": "",
        "order": 50,
        "subcategory": "date",
        "value": theDate
      },
      {
        "id": "25250e2ead108a8f60213f240400248f",
        "name": "ff",
        "label": "FF",
        "head": false,
        "reversal": false,
        "required": false,
        "min": 0,
        "max": 10,
        "instance": "25250e2ead108a8f60213f2404006a4d",
        "regex": "",
        "order": 50,
        "subcategory": "integer",
        "value": ""
      },
      {
        "id": "b9ad37ea17a58d9be32160f393771cdd",
        "name": "yer",
        "label": "Yer",
        "head": true,
        "reversal": false,
        "required": false,
        "min": "",
        "max": "",
        "instance": "25250e2ead108a8f60213f240400717c",
        "regex": "",
        "order": 50,
        "subcategory": "boolean",
        "value": false
      }]
    }],
    "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
    "created_by_": "admin"
  };
};
var past_doc = function (theDate) {
  return {
    "_id": "25250e2ead108a8f60213f2404007c91",
    "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
    "doctype": "bim",
    "description": "",
    "fieldsets": [{
      "id": "b9ad37ea17a58d9be32160f393770e5d",
      "multiple": false,
      "collapse": false,
      "name": "hip",
      "label": "Hip",
      "order": 50,
      "fields": [{
        "id": "25250e2ead108a8f60213f24040007e4",
        "name": "caltest",
        "label": "CalTest",
        "head": false,
        "reversal": false,
        "required": false,
        "min": "today",
        "max": "",
        "instance": "25250e2ead108a8f60213f2404005d38",
        "regex": "",
        "order": 50,
        "subcategory": "date",
        "value": theDate
      },
      {
        "id": "25250e2ead108a8f60213f240400248f",
        "name": "ff",
        "label": "FF",
        "head": false,
        "reversal": false,
        "required": false,
        "min": 0,
        "max": 10,
        "instance": "25250e2ead108a8f60213f2404006a4d",
        "regex": "",
        "order": 50,
        "subcategory": "integer",
        "value": ""
      },
      {
        "id": "b9ad37ea17a58d9be32160f393771cdd",
        "name": "yer",
        "label": "Yer",
        "head": true,
        "reversal": false,
        "required": false,
        "min": "",
        "max": "",
        "instance": "25250e2ead108a8f60213f240400717c",
        "regex": "",
        "order": 50,
        "subcategory": "boolean",
        "value": false
      }]
    }],
    "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
    "created_by_": "admin"
  };
};
var today_doc = function (theDate) {
  return {
    "_id": "25250e2ead108a8f60213f2404007c91",
    "_rev": "1-6ec90301ac115fed382a77207e81a9ca",
    "doctype": "bim",
    "description": "",
    "fieldsets": [{
      "id": "b9ad37ea17a58d9be32160f393770e5d",
      "multiple": false,
      "collapse": false,
      "name": "hip",
      "label": "Hip",
      "order": 50,
      "fields": [{
        "id": "25250e2ead108a8f60213f24040007e4",
        "name": "caltest",
        "label": "CalTest",
        "head": false,
        "reversal": false,
        "required": false,
        "min": "today",
        "max": "today",
        "instance": "25250e2ead108a8f60213f2404005d38",
        "regex": "",
        "order": 50,
        "subcategory": "date",
        "value": theDate
      },
      {
        "id": "25250e2ead108a8f60213f240400248f",
        "name": "ff",
        "label": "FF",
        "head": false,
        "reversal": false,
        "required": false,
        "min": 0,
        "max": 10,
        "instance": "25250e2ead108a8f60213f2404006a4d",
        "regex": "",
        "order": 50,
        "subcategory": "integer",
        "value": ""
      },
      {
        "id": "b9ad37ea17a58d9be32160f393771cdd",
        "name": "yer",
        "label": "Yer",
        "head": true,
        "reversal": false,
        "required": false,
        "min": "",
        "max": "",
        "instance": "25250e2ead108a8f60213f240400717c",
        "regex": "",
        "order": 50,
        "subcategory": "boolean",
        "value": false
      }]
    }],
    "created_at_": "Tue Aug 23 2011 22:03:24 GMT-0500 (CDT)",
    "created_by_": "admin"
  };
};
/*
 * Date.toLocaleFormat.js
 * 
 * Copyright (c) 2012 Tomasz Jakub Rup <tomasz.rup@gmail.com>
 *
 * https://github.com/tomi77/Date.toLocaleFormat/
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

if (!Date.toLocaleFormat) {
	/**
	 * Converts a date to a string using the specified formatting.
	 * 
	 * The toLocaleFormat() provides greater software control over the formatting of the generated date and/or time.
	 * Names for months and days of the week are localized using the operating system's locale. However, ordering of
	 * the day and month and other localization tasks are not handled automatically since you have control over the
	 * order in which they occur. You should take care that the format string is localized properly according to the
	 * user's system settings. Be aware that the locale used is not necessarily the same as the locale of the browser.
	 * 
	 * @param formatString string A format string in the same format expected by the strftime() function in C.
	 */
	Date.prototype.toLocaleFormat = function(formatString) {
		var self = this;
		
		return formatString.replace(Date.prototype.toLocaleFormat.re, function(match, code, position, str) {
			if (match == '%%') return '%';
			else return Date.prototype.toLocaleFormat[code](self);
		});
	}
	
	Date.prototype.toLocaleFormat.re = /%%|%([aAbBcCdDeFgGhHkIjlmMnprRsStTxXyYzZ])/g;
	
	Date.prototype.toLocaleFormat.weekDayNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
	Date.prototype.toLocaleFormat.weekDayNamesShort = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
	
	Date.prototype.toLocaleFormat.monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
	Date.prototype.toLocaleFormat.monthNamesShort = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
	
	Date.prototype.toLocaleFormat.extend = function(str, fill, max_len) {
		if (typeof fill == 'undefined') fill = '0';
		if (typeof max_len == 'undefined') max_len = 2;
		str = String(fill) + String(str);
		return str.substr(-max_len);
	}
	
	/**
	 * %a is replaced by the locale's abbreviated weekday name.
	 */
	Date.prototype.toLocaleFormat.a = function(d) {
		return Date.prototype.toLocaleFormat.weekDayNamesShort[d.getDay()];
	}
	/**
	 * %A is replaced by the locale's full weekday name.
	 */
	Date.prototype.toLocaleFormat.A = function(d) {
		return Date.prototype.toLocaleFormat.weekDayNames[d.getDay()];
	}
	/**
	 * %b and %h is replaced by the locale's abbreviated month name.
	 */
	Date.prototype.toLocaleFormat.b
	Date.prototype.toLocaleFormat.h = function(d) {
		return Date.prototype.toLocaleFormat.monthNamesShort[d.getMonth()];
	}
	/**
	 * %B is replaced by the locale's full month name.
	 */
	Date.prototype.toLocaleFormat.B = function(d) {
		return Date.prototype.toLocaleFormat.monthNames[d.getMonth()];
	}
	/**
	 * %c is replaced by the locale's appropriate date and time representation.
	 */
	Date.prototype.toLocaleFormat.c = function(d) {
		return d.toLocaleString();
	}
	/**
	 * %C is replaced by the century number (the year divided by 100 and truncated to an integer) as a decimal number [00-99].
	 */
	Date.prototype.toLocaleFormat.C = function(d) {
		return new String(d.getFullYear()).substr(0,2);
	}
	/**
	 * %d is replaced by the day of the month as a decimal number [01,31].
	 */
	Date.prototype.toLocaleFormat.d = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getDate());
	}
	/**
	 * %D same as %m/%d/%y.
	 */
	Date.prototype.toLocaleFormat.D = function(d) {
		return d.toLocaleFormat('%m/%d/%y');
	}
	/**
	 * %e is replaced by the day of the month as a decimal number [1,31]; a single digit is preceded by a space.
	 */
	Date.prototype.toLocaleFormat.e = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getMonth()+1, ' ');
	}
	Date.prototype.toLocaleFormat.F = function(d) {
		return d.toLocaleFormat('%Y-%m-%d');
	}
	/**
	 * %y and %g is replaced by the year without century as a decimal number [00,99].
	 */
	Date.prototype.toLocaleFormat.g =
	Date.prototype.toLocaleFormat.y = function(d) {
		return new String(d.getFullYear()).substr(2);
	}
	/**
	 * %Y and %G is replaced by the year with century as a decimal number.
	 */
	Date.prototype.toLocaleFormat.G =
	Date.prototype.toLocaleFormat.Y = function(d) {
		return d.getFullYear();
	}
	/**
	 * %H and k is replaced by the hour (24-hour clock) as a decimal number [00,23].
	 */
	Date.prototype.toLocaleFormat.H = 
	Date.prototype.toLocaleFormat.k = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getHours());
	}
	/**
	 * %I is replaced by the hour (12-hour clock) as a decimal number [01,12].
	 */
	Date.prototype.toLocaleFormat.I = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getHours() % 12);
	}
	/**
	 * %j is replaced by the day of the year as a decimal number [001,366].
	 */
	Date.prototype.toLocaleFormat.j = function(d) {
		var n = 0;
		for (var i = 0; i < d.getMonth(); i++) {
			n += 30;
		}
		n += d.getDate();
	}
	/**
	 * %l is replaced by the hour (12-hour clock) as a decimal number [1,12]; a single digit is preceded by a space.
	 */
	Date.prototype.toLocaleFormat.l = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getHours() % 12, ' ');
	}
	/**
	 * %m is replaced by the month as a decimal number [01,12].
	 */
	Date.prototype.toLocaleFormat.m = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getMonth()+1);
	}
	/**
	 * %M is replaced by the minute as a decimal number [00,59].
	 */
	Date.prototype.toLocaleFormat.M = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getMinutes());
	}
	/**
	 * %n is replaced by a newline character.
	 */
	Date.prototype.toLocaleFormat.n = function() {
		return '\n';
	}
	/**
	 * %p is replaced by the locale's equivalent of either a.m. or p.m.
	 */
	Date.prototype.toLocaleFormat.p = function(d) {
		return ['AM','PM'][Math.floor(d.getHours()/12)];
	}
	/**
	 * %r is replaced by the time in a.m. and p.m. notation; in the POSIX locale this is equivalent to %I:%M:%S %p.
	 */
	Date.prototype.toLocaleFormat.r = function(d) {
		return d.toLocaleFormat('%I:%M:%S %p');
	}
	/**
	 * %R is replaced by the time in 24 hour notation (%H:%M).
	 */
	Date.prototype.toLocaleFormat.R = function(d) {
		return d.toLocaleFormat('%H:%M');
	}
	/**
	 * %s is replaced by the number of milliseconds since midnight Jan 1, 1970.
	 */
	Date.prototype.toLocaleFormat.s = function(d) {
		return new String(parseInt(d.getTime() / 1000));
	}
	/**
	 * %S is replaced by the second as a decimal number [00,61].
	 */
	Date.prototype.toLocaleFormat.S = function(d) {
		return Date.prototype.toLocaleFormat.extend(d.getSeconds());
	}
	/**
	 * %t is replaced by a tab character.
	 */
	Date.prototype.toLocaleFormat.t = function() {
		return '\t';
	}
	/**
	 * %T is replaced by the time (%H:%M:%S).
	 */
	Date.prototype.toLocaleFormat.T = function(d) {
		return d.toLocaleFormat('%H:%M:%S');
	}
	/**
	 * %u is replaced by the weekday as a decimal number [1,7], with 1 representing Monday.
	 */
	/**
	 * %U is replaced by the week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
	 */
	/**
	 * %V is replaced by the week number of the year (Monday as the first day of the week) as a decimal number [01,53].
	 * If the week containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise,
	 * it is the last week of the previous year, and the next week is week 1.
	 */
	/**
	 * %w is replaced by the weekday as a decimal number [0,6], with 0 representing Sunday.
	 */
	/**
	 * %W is replaced by the week number of the year (Monday as the first day of the week) as a decimal number [00,53].
	 * All days in a new year preceding the first Monday are considered to be in week 0.
	 */
	/**
	 * %x is replaced by the locale's appropriate date representation.
	 */
	Date.prototype.toLocaleFormat.x = function(d) {
		return d.toLocaleDateString();
	}
	/**
	 * %X is replaced by the locale's appropriate time representation.
	 */
	Date.prototype.toLocaleFormat.X = function(d) {
		return d.toLocaleTimeString();
	}
	/**
	 * %z
	 */
	Date.prototype.toLocaleFormat.z = function(d) {
		return d.toString().match(/GMT([+-]\d{4})/)[1];
	}
	/**
	 * %Z is replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists.
	 */
	Date.prototype.toLocaleFormat.Z = function(d) {
		return d.toString().match(/\((.*)\)$/)[1];
	}
}


var testEnv = true;

function validate(newDoc, saveDoc, userCtx) {
  // A predicate function to detect blank strings.
  // Warning: this is a bad implementation.
  var isBlank = function (value) {
    return (((/^\s*$/).test(value)) || (value === null) || (value === undefined) || (typeof value === 'number' && isNaN(value)) || (Object.prototype.toString.call(value) === '[object Array]' && value.length === 0));
  };

  var forbid = function (name, msg) {
    var docid;

    if (newDoc._id) {
      docid = newDoc._id;
    } else {
      docid = 'No ID';
    }

    var errorMsg = JSON.stringify({
      fieldname: name,
      message: msg,
      docid: docid
    });

    // This is used when running unit tests
    if (testEnv) {
      throw new Error(errorMsg);
    } else {
      throw new Error({
        forbidden: errorMsg
      });
    }
  };

  var charseq = function (newDoc, saveDoc, userCtx) {
    if (newDoc.category === 'charseq') {
      if (isBlank(newDoc.name)) {
        forbid('Name', 'must be filled in.');
      }

      [
        [newDoc.characters, 'Characters'],
        [newDoc.sort_ignore, 'Ignore'],
        [newDoc.vowels, 'Vowels'],
        [newDoc.consonants, 'Consonants']
      ].forEach(function (item) {
        if (item[0] === false) {
          forbid(item[1], 'contains quoting errors.');
        }
      });
    }
  };

  var documents = function (newDoc, saveDoc, userCtx) {
    // A more detailed error message function for cases where we
    // want to indication what field caused the problem.
    var forbidField = function (field, msg) {
      var errorMsg = JSON.stringify({
        fieldname: field.name,
        instance: field.instance,
        message: msg
      });

      if (testEnv) {
        throw new Error(errorMsg);
      } else {
        throw ({
          forbidden: errorMsg
        });
      }
    };

    // The following are validation tests that are run for
    // each field by an expression below.
    var requiredField = function (field) {
      if (field.required === true) {
        if (isBlank(field.value)) {
          forbidField(field, 'cannot be blank.');
        }
      }
    };

    // Determine if this is a datefield and run the date validations
    // if it is not blank
    var dateField = function (field) {
      if (field.subcategory === 'date' && !isBlank(field.value)) {
        dateFormat(field);
        dateRange(field);
      }
    };

    // Determine if this is an integer field and the integer validations
    var integerField = function (field) {
      if (field.subcategory === 'integer' && field.value !== '') {
        isValidNumber(field);
        isInteger(field);
        numberRange(field);
      }
    };

    // Determine if this is an rational field and the rational validations
    var rationalField = function (field) {
      if (field.subcategory === 'rational' && field.value !== '') {
        isValidNumber(field);
        numberRange(field);
      }
    };

    // Determine if this is a text field and run appropriate validations
    var textField = function (field) {
      if (field.subcategory === 'text' && !isBlank(field.value)) {
        isString(field);
        isMatch(field);
      }
    };

    // Determine if this is a textarea field and run appropriate validations
    var textareaField = function (field) {
      if (field.subcategory === 'textarea' && !isBlank(field.value)) {
        isString(field);
        isMatch(field);
      }
    };

    // Determine if this is a boolean field make sure it is true or false
    var booleanField = function (field) {
      if (field.subcategory === 'boolean') {
        isBoolean(field);
      }
    };

    // Determine if this is a openboolean field make sure it is true or false
    var openbooleanField = function (field) {
      if (field.subcategory === 'openboolean') {
        isOpenboolean(field);
      }
    };

    // Determine if this is a select field and do appropriate validations
    // NOTE validations on whether a selection is in the list of allowed
    //      values is done in the application layer in the document
    //      resource.
    var selectField = function (field) {
      if (field.subcategory === 'select' && !isBlank(field.value)) {
        isString(field);
      }
    };

    // Determine if this is a docselect field and do appropriate validations
    // NOTE validations on whether a selection is in the list of allowed
    //      values is done in the application layer in the document
    //      resource.
    var docselectField = function (field) {
      if (field.subcategory === 'docselect' && !isBlank(field.value)) {
        isString(field);
      }
    };

    // Determine if this is a docmultiselect field and do appropriate validations
    // NOTE validations on whether a selection is in the list of allowed
    //      values is done in the application layer in the document
    //      resource.
    var docmultiselectField = function (field) {
      if (field.subcategory === 'docmultiselect' && !isBlank(field.value)) {
        isStringArray(field);
      }
    };

    // Determine if this is a multiselect field and do appropriate validations
    // NOTE validations on whether a selection is in the list of allowed
    //      values is done in the application layer in the document
    //      resource.
    var multiselectField = function (field) {
      if (field.subcategory === 'multiselect' && !isBlank(field.value)) {
        isStringArray(field);
      }
    };

    // Ensure that the date is formatted according to the standard of
    // this application.
    var dateFormat = function (field) {
      var pattern = (/^\d{4}-\d{2}-\d{2}$/);

      if (!pattern.test(field.value) && isNaN(Date.parse(field.value))) {
        forbidField(field, 'date must be in format yyyy-mm-dd');
      }
    };

    var myDateToUTC = function (myDate) {

    };

    // Make sure that the date is not outside of a specified range
    var dateRange = function (field) {
      var pattern = (/^\d{4}-\d{2}-\d{2}$/);

      if (pattern.test(field.max)) {
        isEarlier(field);
      }
      if (pattern.test(field.min)) {
        isLater(field);
      }
      if (field.min === 'today' && field.max === 'today') {
        isToday(field);
      } else {
        if (field.min === 'today') {
          isFuture(field);
        }
        if (field.max === 'today') {
          isPast(field);
        }
      }
    };

    // See if a date is earlier than a maximum date. If it isn't fail.
    var isEarlier = function (field) {
      if (field.value >= field.max) {
        var message = 'date must be earlier than or equal to ' + field.max + '.';
        forbidField(field, message);
      }
    };

    // See if a date is later than a minimum date. If it isn't fail.
    var isLater = function (field) {
      if (field.value < field.min) {
        var message = 'date must be later than ' + field.min + '.';
        forbidField(field, message);
      }
    };

    // See if a date should be today. If it isn't fail.
    var isToday = function (field) {
      if (field.value !== new Date().toLocaleFormat('%Y-%m-%d')) {
        forbidField(field, 'date must be today.');
      }
    };

    // See if a date should be in the future. If it isn't fail.
    var isFuture = function (field) {
      if (field.value <= new Date().toLocaleFormat('%Y-%m-%d')) {
        forbidField(field, 'date must be in the future.');
      }
    };

    // See if a date should be in the past. If it isn't fail.
    var isPast = function (field) {
      if (field.value > new Date().toLocaleFormat('%Y-%m-%d')) {
        forbidField(field, 'date must be in the past.');
      }
    };

    var isInteger = function (field) {
      var message = 'Expected an integer but got rational number';

      if (field.value % 1 !== 0) {
        forbidField(field, message);
      }
    };

    // Make sure this is a valid number
    var isValidNumber = function (field) {
      if (!isNumber(field.value)) {
        forbidField(field, 'Not a valid number');
      }
    };

    // Test if it is a number and not NaN.
    var isNumber = function (value) {
      return ((typeof value === 'number') && !(isNaN(value)));
    };

    // Determine if the number is within a given range
    var numberRange = function (field) {
      if (isNumber(field.max) && (field.value > field.max)) {
        forbidField(field, 'Must be less than or equal to ' + field.max);
      }
      if (isNumber(field.min) && (field.value < field.min)) {
        forbidField(field, 'Must be greater than or equal to ' + field.min);
      }
    };

    // Determine if string should match pattern
    var isMatch = function (field) {
      if (!isBlank(field.regex)) {
        var re = new RegExp(field.regex);

        if (!re.test(field.value)) {
          forbidField(field, 'Must match ' + field.regex);
        }
      }
    };

    // Determine if it is an array of strings
    var isStringArray = function (field) {
      if (Object.prototype.toString.call(field.value) !== '[object Array]') {
        forbidField(field, 'Must be an array of strings.');
      }

      field.value.forEach(function (v) {
        if (typeof v !== 'string') {
          forbidField(field, 'Must contain only text.');
        }
      });
    };

    // Determine if it is a string
    var isString = function (field) {
      if (typeof field.value !== 'string') {
        forbidField(field, 'Must be text.');
      }
    };

    // Fail if not a boolean
    var isBoolean = function (field) {
      if (typeof field.value !== 'boolean') {
        forbidField(field, 'Must be true or false.');
      }
    };

    // Fail if neither a boolean nor null
    var isOpenboolean = function (field) {
      if (typeof field.value !== 'boolean' && field.value !== null) {
        forbidField(field, 'Must be true, false or blank.');
      }
    };

    // This is a list of the validation tests to run on each
    // field.
    var validationTests = [requiredField, dateField, booleanField, docmultiselectField, docselectField, integerField, multiselectField, openbooleanField, rationalField, selectField, textField, textareaField];

    // This iterates through the fields and runs the above
    // validation test for each field.
    newDoc.fieldsets.forEach(function (fieldset) {
      if (fieldset.multiple) {
        fieldset.multifields.forEach(function (multifield) {
          multifield.fields.forEach(function (field) {
            validationTests.forEach(function (vTest) {
              vTest(field);
            });
          });
        });
      } else {
        fieldset.fields.forEach(function (field) {
          validationTests.forEach(function (vTest) {
            vTest(field);
          });
        });
      }
    });
  };

  var userIndex = function (newDoc, saveDoc, userCtx) {
    [newDoc.doctype, newDoc.name].forEach(

    function (field) {
      if (isBlank(field)) {
        forbid('All fields', 'must be filled in.');
      }
    });

    if (newDoc.fields.length === 0 || newDoc.fieldLabel === 0) {
      forbid('All fields', 'must be filled in.');
    }

    if (typeof newDoc.show_deleted !== 'boolean') {
      forbid('Show deleted', 'must be true or false');
    }

    if (!(/^\w*$/).test(newDoc.name)) {
      forbid('Name', 'may only contain alphanumeric characters and underscores.');
    }

    if (newDoc.conditions && newDoc.conditions.length > 0) {
      var firstCondition = newDoc.conditions[0];
      var lastCondition = newDoc.conditions[newDoc.conditions.length - 1];
      var parenCount = 0;
      var exParenCount = 0;
      var exParenFS = false;

      if (firstCondition.is_or === true || lastCondition.is_or === true) {
        forbid('Conditions', 'may not begin or end with OR.');
      }

      if (firstCondition.parens === 'close' || firstCondition.parens === 'exclose' || lastCondition.parens === 'exopen' || lastCondition.parens === 'open') {
        forbid('Conditions', 'begin or end with improper parenthesis.');
      }

      newDoc.conditions.forEach(

      function (condition, index) {
        var is_or = condition.is_or;
        var negate = condition.negate;
        var argument = condition.argument;
        var operator = condition.operator;
        var field = condition.field;
        var fieldset = condition.fieldset;
        var parens = condition.parens;

        if (parenCount < 0 || exParenCount < 0) {
          forbid('Condition ' + index, 'too many closing parenthesis.');
        }

        if (exParenCount > 1) {
          forbid('Condition ' + index, 'existential parenthesis cannot be nexted.');
        }

        if (is_or !== true && (parens !== 'open' && parens !== 'close' && parens !== 'exopen' && parens !== 'exclose')) {

          if (negate !== true && negate !== false) {
            forbid('Condition ' + index, 'negate must be true or false');
          }

          if (isBlank(field) || !(/^\w*$/).test(field)) {
            forbid('Condition ' + index, 'invalid field.');
          }

          if (isBlank(fieldset) || !(/^\w*$/).test(fieldset)) {
            forbid('Condition ' + index, 'invalid fieldset.');
          }

          switch (operator) {
          case 'hasGreater':
          case 'hasLess':
          case 'hasExactly':
            if (typeof argument !== 'number' || (argument % 1) > 0) {
              forbid('Condition ' + index, 'integer argument required.');
            }
            break;
          case 'equal':
          case 'match':
          case 'greater':
          case 'less':
          case 'match':
          case 'member':
            if (typeof argument === 'string' && isBlank(argument)) {
              forbid('Condition ' + index, 'blank argument is not allowed.');
            }
            break;
          case 'true':
          case 'blank':
          case 'isDefined':
            if (!isBlank(argument)) {
              forbid('Condition ' + index, 'no argument allowed for this condition.');
            }
            break;
          default:
            forbid('Condition ' + index, 'invalid operator.');
          }
        }

        if (parens === 'open') {
          parenCount = parenCount + 1;
        } else if (parens === 'close') {
          parenCount = parenCount - 1;
        } else if (parens === 'exopen') {
          exParenCount = exParenCount + 1;
        } else if (parens === 'exclose') {
          exParenCount = exParenCount - 1;
          exParenFS = false;
        }

        if (!parens && exParenCount === 1) {
          if (exParenFS) {
            if (exParenFS !== fieldset && !is_or) {
              forbid('Condition ' + index, 'all conditions within existential scope must have ' + 'the same fieldset.');
            }
          } else {
            exParenFS = fieldset;
          }
        }
      });

      if (parenCount !== 0 || exParenCount !== 0) {
        forbid('Condition', 'unclosed parenthesis.');
      }
    }
  };

  // readonly users cannot write a document
  if (userCtx.roles.indexOf('readonly') !== -1) {
    forbid(userCtx.name, 'is a read only user.');
  }

  if (newDoc.category === "charseq") {
    charseq(newDoc, saveDoc, userCtx);
    return "ok";
  } else if (newDoc.category === 'index') {
    userIndex(newDoc, saveDoc, userCtx);
    return "ok";
  } else if (!newDoc.category && !! newDoc.doctype && !newDoc.deleted_) {
    documents(newDoc, saveDoc, userCtx);
    return "ok";
  }

  return "skipped";
}

var assert = require("should");

var roUser = function () {
  validate(simple_doc, {}, {
    name: "charlie",
    roles: ["readonly"]
  });
};

var testCase = function (newDoc, saveDoc) {
  var testInstance = function () {
    return validate(newDoc, saveDoc, {name: "charlie", roles: []});
  };
  
  return testInstance;
};

var manipDate = function(days) {
  var myDate = new Date();
  var newDate = myDate.setDate(myDate.getDate() + days);
  
  return new Date(newDate).toLocaleFormat('%Y-%m-%d');
};

describe("CouchDB validation", function () {
  describe("when testing for a valid user", function() {
    it("should block changes by a readonly user", function () {
      roUser.should.throwError(/is a read only user./);      
    });
  });
  describe("when validating documents created by a user", function() {
    describe("in simple cases", function() {
      it("should ignore empty new and saved documents", function () {
        testCase({}, {})().should.equal("skipped");
      });
      it("should ignore the document if the saved document is null", function() {
        testCase({})().should.equal("skipped");
      });
      it("should pass a valid document", function() {
        testCase(simple_doc)().should.equal("ok");
      });
    });
    describe("and dealing with integers", function() {
      it("should reject integers that are above the maximum", function() {
        testCase(high_integer).should.throwError(/Must be less than or equal to 0/);
      });
      it("should reject integers that are below the minimum", function() {
        testCase(lower_integer).should.throwError(/Must be greater than or equal to 0/);
      });
    });
    describe("and dealing with dates", function() {
      it("should reject a bad date format", function() {
        testCase(bad_format_doc).should.throwError(/date must be in format yyyy-mm-dd/);
      });
      it("should reject dates that are below the minimum", function() {
        testCase(early_doc).should.throwError(/date must be later than 1990-09-23./);
      });
      it("should reject dates that are above the maximum", function() {
        testCase(late_doc).should.throwError(/date must be earlier than or equal to 1990-07-23./);
      });
      it("should reject dates that are below the relative minimum, i.e. today", function() {
        testCase(past_doc(manipDate(-1))).should.throwError(/date must be in the future./);
      });
      it("should reject dates that are equal to the relative minimum, i.e. today", function() {
        testCase(past_doc(manipDate(0))).should.throwError(/date must be in the future./);
      });
      it("should reject dates that are above the relative maximum, i.e. today", function() {
        testCase(future_doc(manipDate(1))).should.throwError(/date must be in the past./);
      });
      it("should accept today's date when both the maximum and minimum are today", function() {
        testCase(today_doc(manipDate(0)))().should.equal("ok");
      });
      it("should reject tomorrow's date when both the maximum and minimum are today", function() {
        testCase(today_doc(manipDate(1))).should.throwError(/date must be today./);
      });
      it("should reject yesterday's date when both the maximum and minimum are today", function() {
        testCase(today_doc(manipDate(-1))).should.throwError(/date must be today./);
      });
    });
  });
});