function(newDoc, saveDoc, userCtx) {
    String.prototype.isBlank = function() {
        return ((/^\\s*$/).test(this) && 
                !(/\\S/).test(this) && 
                !(this === null));
    };

    var isArray = function(anArray) {
        return Object.prototype.toString.apply(anArray) == '[object Array]';
    };
  
    var forbid = function(name, msg) {
        var errorMsg = JSON.stringify({
            fieldname: name,
            message: msg
        });

        throw({forbidden: errorMsg});
    };
  
    if (newDoc.category === 'index') {
        [newDoc.doctype, newDoc.name]
            .forEach(
                function(field) {
                    if (field.isBlank()) {
                        forbid('All fields', 'must be filled in.');
                    }
                });
    
        if (newDoc.fields.length === 0 || newDoc.fieldLabel === 0) {
            forbid('All fields', 'must be filled in.');  
        }

        if (typeof newDoc.show_deleted !== 'boolean') {
            forbid('Show deleted', 'must be true or false');
        }

        if (!(/^\\w*$/).test(newDoc.name)) {
            forbid('Name', 
                   'may only contain alphanumeric characters and underscores.');
        }
    
        if (newDoc.conditions && newDoc.conditions.length > 0) {
            var firstCondition = newDoc.conditions[0];
            var lastCondition = newDoc.conditions[newDoc.conditions.length - 1];
            var parenCount = 0;
      
            if (firstCondition.is_or == true || lastCondition.is_or == true) {
                forbid('Conditions', 'may not begin or end with OR.');
            }

            if (firstCondition.parens === 'close' || 
                lastCondition.parens === 'open') {
                forbid('Conditions', 
                       'begin or end with improper grouping term.');
            }
      
            newDoc.conditions.forEach(function(condition, index) {
                var is_or = condition.is_or;
                var negate = condition.negate;
                var argument = condition.argument;
                var operator = condition.operator;
                var field = condition.field;
                var fieldset = condition. fieldset;
        
                if (parenCount < 0) {
                    forbid('Condition ' + index, 
                           'improperly grouped expression.');
                }

                if (is_or != true) {
        
                    if (negate != true && negate != false) {
                        forbid('Condition ' + index, 
                               'negate must be true or false');
                    }
          
                    if (field.isBlank() || !(/^\\w*$/).test(field)) {
                        forbid('Condition ' + index, 'invalid field.');
                    }
          
                    if (fieldset.isBlank() || !(/^\\w*$/).test(fieldset)) {
                        forbid('Condition ' + index, 'invalid fieldset.');
                    } 
          
                    switch (operator) {
                    case 'hasGreater':
                    case 'hasLess':
                    case 'hasExactly':
                        if (typeof argument !== 'number' || 
                            (argument % 1) > 0) {
                            forbid('Condition ' + index, 
                                   'integer argument required.');
                        }
                    case 'equal':
                    case 'match':
                    case 'greater': 
                    case 'less':
                    case 'match':
                    case 'member':
                        if (typeof argument === 'string' && 
                            argument.isBlank()) {
                            forbid('Condition ' + index, 
                                   'blank argument is not allowed.');
                        }
                        break;
                    case 'true':
                    case 'blank':
                    case 'isDefined':
                        if (!argument.isBlank()) {
                            forbid('Condition ' + index, 
                                   'no argument allowed for this condition.');
                        }
                        break;
                    default:
                        forbid('Condition ' + index, 'invalid operator.');
                    }
                } 
            });

            if (parenCount !== 0) {
                forbid('Condition', 'unclosed group expression.');
            }
        }
    }
}
