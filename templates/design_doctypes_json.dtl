{
  "_id": "_design/doctypes",
  "views": {
    "all": {
      "map": "function(doc) { 
        if (doc.category == 'doctype')  { emit(doc._id, doc) }
      }"
    },
    "all_simple": {
      "map": "function(doc) { 
        if (doc.category == 'doctype')  { emit(doc._id, doc.description) }
      }"
    }
  },
  "updates": {
    "stamp": "function(doc, req) {
      var newDoc = JSON.parse(req.body);
      var now = (new Date()).toString();

      if (!doc) {
        if (newDoc._id) {
          newDoc.created_at_ = now;
          newDoc.created_by_ = req.userCtx.name;
          message = 'Created at ' + now.toString + ' by ' + req.userCtx.name;
          return [newDoc, message];
        }
        
        return [null, 'This application expects the document _id in the JSON body'];
      }

      newDoc.updated_at_ = now;
      newDoc.updated_by_ = req.userCtx.name;
      newDoc.created_at_ = doc.created_at_;
      if (doc.create_user_) {
        newDoc.created_by_ = doc.create_user_;
      } else {
        newDoc.created_by_ = doc.created_by_;
      }
      message = 'Updated at ' + now.toString + ' by ' + req.userCtx.name;
      
      return [newDoc, message];
    }"
  },
  "validate_doc_update": "
    function(newDoc, saveDoc, userCtx) {
    
      // A predicate function to detect blank strings
      
      var isBlank = function(value) {
        return (((/^\\s*$/).test(value)) || 
                (value === null) || 
                (value === undefined) ||
                (typeof value === 'number' && isNaN(value)) ||
                (Object.prototype.toString.call(value) === '[object Array]' && value.length === 0));
      };

      // Wrapper to send back error message to user as JSON.
      
      var forbid = function(name, msg) {
        var docid;
        
        if (newDoc._id) {
          docid = newDoc._id;
        } else if (saveDoc._id) {
          docid = saveDoc._id;
        } else {
          docid = 'No ID';
        }
        
        var errorMsg = JSON.stringify({
          fieldname: name,
          message: msg,
          docid: docid
        });

        throw({forbidden: errorMsg});
      };
 
      // A more detailed error message function for cases where we
      // want to indication what field caused the problem.
      
      var forbidField = function(field, msg) {
        var errorMsg = JSON.stringify({
          fieldname: field.name,
          instance: field.instance,
          message: msg
        });

        throw({forbidden: errorMsg});
      };
 
      // readonly users cannot write a document
      
      if (userCtx.roles.indexOf('readonly') !== -1) {
        forbid(userCtx.name, 'is a read only user.');
      }
            
      // The following are validation tests that are run for
      // each field by an expression below.
            
      var requiredField = function(field) {
        if (field.required === true) {
          if (isBlank(field.value)) {
            forbidField(field, 'cannot be blank.');
          }            
        }              
      };
      
      // Determine if this is a datefield and run the date validations
      // if it is not blank
      
      var dateField = function(field) {
        if (field.subcategory === 'date' && !isBlank(field.value)) {
          dateFormat(field);
          dateRange(field);
        }
      };
      
      // Determine if this is an integer field and the integer validations
      
      var integerField = function(field) {
        if (field.subcategory === 'integer' && field.value !== '') {
          isValidNumber(field);
          isInteger(field);
          numberRange(field);
        }
      };
      
      // Determine if this is an rational field and the rational validations
      
      var rationalField = function(field) {
        if (field.subcategory === 'rational' && field.value !== '') {
          isValidNumber(field);
          numberRange(field);
        }
      };
      
      // Determine if this is a text field and run appropriate validations
      
      var textField = function(field) {
        if (field.subcategory === 'text' && !isBlank(field.value)) {
          isString(field);
          isMatch(field);
        }
      };
      
      // Determine if this is a textarea field and run appropriate validations
      
      var textareaField = function(field) {
        if (field.subcategory === 'textarea' && !isBlank(field.value)) {
          isString(field);
          isMatch(field);
        }
      };
      
      // Determine if this is a boolean field make sure it is true or false
      
      var booleanField = function(field) {
        if (field.subcategory === 'boolean') {
          isBoolean(field);
        }
      };
      
      // Determine if this is a openboolean field make sure it is true or false
      
      var openbooleanField = function(field) {
        if (field.subcategory === 'openboolean') {
          isOpenboolean(field);
        }
      };
      
      // Determine if this is a select field and do appropriate validations
      // NOTE validations on whether a selection is in the list of allowed
      //      values is done in the application layer in the document
      //      resource.
      
      var selectField = function(field) {
        if (field.subcategory === 'select' && !isBlank(field.value)) {
          isString(field);
        }
      };
      
      // Determine if this is a docselect field and do appropriate validations
      // NOTE validations on whether a selection is in the list of allowed
      //      values is done in the application layer in the document
      //      resource.
      
      var docselectField = function(field) {
        if (field.subcategory === 'docselect' && !isBlank(field.value)) {
          isString(field);
        }
      };
      
      // Determine if this is a docmultiselect field and do appropriate validations
      // NOTE validations on whether a selection is in the list of allowed
      //      values is done in the application layer in the document
      //      resource.
      
      var docmultiselectField = function(field) {
        if (field.subcategory === 'docmultiselect' && !isBlank(field.value)) {
          isStringArray(field);
        }
      };
      
      // Determine if this is a multiselect field and do appropriate validations
      // NOTE validations on whether a selection is in the list of allowed
      //      values is done in the application layer in the document
      //      resource.
      
      var multiselectField = function(field) {
        if (field.subcategory === 'multiselect' && !isBlank(field.value)) {
          isStringArray(field);
        }
      };

      // Ensure that the date is formatted according to the standard of
      // this application.
      
      var dateFormat = function(field) {
        var pattern = (/^\\d{4}-\\d{2}-\\d{2}$/);

        if (!pattern.test(field.value) && isNaN(Date.parse(field.value))) {
          forbidField(field, 'date must be in format yyyy-mm-dd');
        }
      };

      // Make sure that the date is not outside of a specified range
      
      var dateRange = function(field) {
        var now = new Date();
        var given = Date.parse(field.value);

        [isPast, isFuture, isLater, isEarlier].forEach(function(fun) {
          fun(field, given, now);
        });
      };

      // See if a date is earlier than a maximum date. If it isn't fail.
      
      var isEarlier = function(field, given, now) {
        var max = Date.parse(field.max);
        
        if (!isNaN(max) && given >= max) {
          var maxDate = new Date(max);
          var message = 'date must be earlier than or equal to ' + maxDate.toDateString() + '.';

          forbidField(field, message);
        }
      };
      
      // See if a date is later than a minimum date. If it isn't fail.
      
      var isLater = function(field, given, now) {
        var min = Date.parse(field.min);
        
        if (!isNaN(min) && given < min) {
          var minDate = new Date(min);
          var message = 'date must be later than ' + minDate.toDateString() + '.';

          forbidField(field, message);
        }
      };
      
      // See if a date should be in the future. If it isn't fail.
      
      var isFuture = function(field, given, now) {
        if (field.min === 'today' && given <= now) {
          forbidField(field, 'date must be in the future.');
        }
      };
      
      // See if a date should be in the past. If it isn't fail.
      
      var isPast = function(field, given, now) {
        if (field.max === 'today' && given > now) {
          forbidField(field, 'date must be in the past.');
        }
      };
      
      var isInteger = function(field) {
        var message = 'Expected an integer but got rational number';
        
        if (field.value % 1 !== 0) {
          forbidField(field, message);
        }
      };
      
      // Make sure this is a valid number
      
      var isValidNumber = function(field) {
        if (!isNumber(field.value)) {
          forbidField(field, 'Not a valid number');
        }
      };
      
      // Test if it is a number and not NaN.
      
      var isNumber = function(value) {
        return ((typeof value === 'number') && !(isNaN(value)));
      };
      
      // Determine if the number is within a given range
      
      var numberRange = function(field) {
        if (isNumber(field.max) && (field.value > field.max)) {
          forbidField(field, 'Must be less than or equal to ' + field.max);
        }
        if (isNumber(field.min) && (field.value < field.min)) {
          forbidField(field, 'Must be greater than or equal to ' + field.min);
        }
      };
      
      // Determine if string should match pattern
      
      var isMatch = function(field) {
        if (!isBlank(field.regex)) {
          var re = new RegExp(field.regex);
          
          if (!re.test(field.value)) {
            forbidField(field, 'Must match ' + field.regex);
          }
        }
      };
      
      // Determine if it is an array of strings
      
      var isStringArray = function(field) {
        if (Object.prototype.toString.call(field.value) !== '[object Array]') {
          forbidField(field, 'Must be an array of strings.');
        }
        
        field.value.forEach(function(v) {
          if (typeof v !== 'string') {
            forbidField(field, 'Must contain only text.');
          }
        });
      };
      
      // Determine if it is a string
      
      var isString = function(field) {
        if (typeof field.value !== 'string') {
          forbidField(field, 'Must be text.');
        }
      };
      
      // Fail if not a boolean
      
      var isBoolean = function(field) {
        if (typeof field.value !== 'boolean') {
          forbidField(field, 'Must be true or false.');
        }
      };
      
      // Fail if neither a boolean nor null
      
      var isOpenboolean = function(field) {
        if (typeof field.value !== 'boolean' && field.value !== null) {
          forbidField(field, 'Must be true, false or blank.');
        }
      };
      
      // This is a list of the validation tests to run on each
      // field.
            
      var validationTests = [requiredField, dateField, booleanField, docmultiselectField, docselectField, integerField, multiselectField, openbooleanField, rationalField, selectField, textField, textareaField];
      
      // This iterates through the fields and runs the above
      // validation test for each field.
            
      if (!newDoc.category && !!newDoc.doctype) {
        newDoc.fieldsets.forEach(function(fieldset) {
          if (fieldset.multiple) {
            fieldset.multifields.forEach(function(multifield) {
              multifield.fields.forEach(function(field) {
                validationTests.forEach(function(vTest) {
                  vTest(field);
                });
              });
            });
          } else {
            fieldset.fields.forEach(function(field) {
              validationTests.forEach(function(vTest) {
                vTest(field);
              });
            });
          }
        });
      }
    }
  "
}
